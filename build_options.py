# This is a python program to generate the options setting and examples
# in the destriper.
#
# It will certainly work as far back as python2.5, and possibly 2.4.
#

import StringIO

DEFAULT_PARAMETER_FILENAME = "default_params.ini"
SHORT_PARAMETER_FILENAME = "short_params.ini"
import sys
FORTRAN_FILENAME = sys.argv[1]

#(Parameter_name,Parameter_type,Default_value,Help_text)

basic_options=[
("file_list",str,"files.txt","List of FITS files to make maps from"),
("nside",int,128,"The Healpix NSIDE parameter of the output maps"),
("offsetLength",int,1000,"The length of the destriping offsets.  Set to the special value of -1 to use a single offset per scan."),
("naive_mode",bool,False,"Make a naive map without destriping"),
("traditional_mode",bool,True,"Do not use noise information when destriping"),
("do_temperature",bool,True,"Make temperature maps"),
("do_polarization",bool,False,"Make temperature maps"),
("min_hits",int,1,"Minimum number of hits on a pixel for it to be used"),
("leakage_matrix",str,"","A text file listing the leakage matrix"),
]

output_options=[
("verbosity",int,2,"Verbosity level of code.  0=silent, 1=quiet, 2=noisy, 3=debug.  Default is 2."),
("output_filename",str,"map.fits","Filename for the output maps"),
("hits_filename",str,"map.hits","Filename for the output hit count map"),
("save_covariance",bool,True,"Save the covariance of the output map"),
("covariance_filename",str,"cov.fits","Filename for the output covariance.  Fits format if it ends in .fits or .fit, (cases insensitive), text otherwise"),
("save_offsets",bool,False,"Save the offsets fitted to the timestream in destriping"),
("offset_dir",str,"offsets/","Directory in which to save the offsets"),
("ring_ordering",bool,True,"Whether to use Healpix ring ordering for the output map"),
]

pcg_options=[
("pcg_tolerance",float,1.0e-6,"The tolerance of the PCG solver."),
("pcg_iterations", int, 200, "The maximum number of PCG iterations"),
("data_prior",bool,False,"Construct the prior on the timestream noise directly from the data"),
]

options=[
("Basic Options",basic_options),
("Ouput Control Options",output_options),
("Destriping Conjugate Gradient Options",pcg_options),
]



def fortran_string(value,ptype):
	if ptype==str:
		return '"%s"'%value
	elif ptype in (float,int):
		return str(value)
	elif ptype==bool:
		if value:
			return '.true.'
		else:
			return '.false.'
	else:
		raise ValueError("Unknown parameter type")

def declaration_string(ptype):
	if ptype==str:
		return 'character(256) :: '
	elif ptype == float:
		return 'real(dp) :: '
	elif ptype == int:
		return 'integer :: '
	elif ptype==bool:
		return 'logical :: '
	else:
		raise ValueError("Unknown parameter type")
	
FITS_CODES = {
		float : "D",
		int : "J",
		bool  : "L",
		str : "S"
	}

FORTRAN_CODES={
	float:'E10.5',
	str:'A',
	int:'I0',
	bool:'L'
}	

def ini_string(value,ptype):
	if ptype in (float,int,str):
		return str(value)
	elif ptype==bool:
		if value:
			return 'T'
		else:
			return 'F'
	else:
		raise ValueError("Unknown parameter type")


def ini_call_for_type(ptype):
	if ptype==str:
		return "ini_read_string_file2"
	elif ptype==float:
		return "ini_read_double_file"
	elif ptype==int:
		return "ini_read_int_file"
	elif ptype==bool:
		return "ini_read_logical_file"
	else:
		raise ValueError("Unknown parameter type")
	
def parse_call_for_type(ptype,value):
	if ptype==str:
		return 'trim(%s)'%value
	elif ptype==float:
		return 'ds_atof(%s)'%value
	elif ptype==int:
		return 'ds_atoi(%s)'%value
	elif ptype==bool:
		return 'ds_atob(%s)'%value
	else:
		raise ValueError("Unknown parameter type")
		
	

def generate_fortran(options):
	S=StringIO.StringIO()
	S.write("""! DO NOT EDIT THIS FILE - IT IS GENERATED FROM build_options.py. Edit that.

module ds_cbass_option_utils
use inifile
use healpix_types
use ds_utils
implicit none

type ds_cbass_options
""")

	for set_name,option_set in options:
		S.write("\n\t!!!!!!!!!!!!!!!!!\n")		
		S.write("\t!!! %s\n"%set_name)		
		S.write("\t!!!!!!!!!!!!!!!!!\n\n")
		for name,ptype,default,help in option_set:
			S.write("\t!%s\n"%help)
			S.write("\t%s%s\n\n"%(declaration_string(ptype),name))
	S.write("end type ds_cbass_options\n\n\n")
	S.write("contains\n\n")

	S.write("subroutine set_default_options(options)\n")
	S.write("\ttype(ds_cbass_options) :: options\n")
	for set_name,option_set in options:
		for name,ptype,default,help in option_set:
			S.write("\toptions%%%s = %s\n"%(name,fortran_string(default,ptype)) )
	S.write("end subroutine set_default_options\n\n\n")
	
	S.write("""
subroutine read_options(filename,options)
	type(ds_cbass_options) :: options
	character(*) :: filename
	Type(TIniFile) :: Ini
	integer unit
	logical error
	
	unit=ds_get_lun()
	call Ini_Open_File(ini, trim(filename), unit,  error)
  	if (error) then
		write(*,*) 'Unable to open or read file: '//trim(filename)
		stop
	endif
	
	call set_default_options(options)

""")
	for set_name,option_set in options:
		for name,ptype,default,help in option_set:
			S.write("\toptions%%%s = %s(ini,'%s',options%%%s)\n" % (name,ini_call_for_type(ptype),name,name ) )
	S.write("end subroutine read_options\n\n\n")
	
	S.write("""
subroutine options_to_fits_cards(options,cards)
	use fl_lists
	type(ds_cbass_options) :: options
	integer unit
	type(fl_string80_list) :: cards
	character(256) :: template
	character(80) :: card
	integer status, hdutype
	status=0
	hdutype=0
	template='COMMENT  ------------------------'
	call FTGTHD(trim(template),card,hdutype,status)
	if (status .ne. 0) then 
		write(*,'(A,I0,A)') "ERROR ",status," PARSING:"
		write(*,'(A)') trim(template)
	endif
	call fl_append_string80_list(cards,card)
	template='COMMENT  ---LIST OF MAPMAKING PARAMETERS---'
	call FTGTHD(trim(template),card,hdutype,status)
	if (status .ne. 0) then 
		write(*,'(A,I0,A)') "ERROR ",status," PARSING:"
		write(*,'(A)') trim(template)
	endif
	call fl_append_string80_list(cards,card)
	template='COMMENT  ------------------------'
	call FTGTHD(trim(template),card,hdutype,status)
	if (status .ne. 0) then 
		write(*,'(A,I0,A)') "ERROR ",status," PARSING:"
		write(*,'(A)') trim(template)
	endif
	call fl_append_string80_list(cards,card)
	
""")
	i=0
	for set_name,option_set in options:
		for (name,ptype,default,help) in option_set:
			fits_card(S,i,name,ptype,help)
			i+=1
	S.write("end subroutine options_to_fits_cards\n")	
	
	S.write("""
	
subroutine parse_parameter_line(input_line,name,value)
	character(*) :: input_line
	character(*) :: name, value
	character(len=len(input_line)) :: InLine, S, AName
	integer EqPos, slashpos, lastpos


	InLine=trim(adjustl(input_line))
	EqPos = scan(InLine,'=')

	if (EqPos/=0 .and. InLine(1:1)/='#' .and. InLine(1:7) /= 'COMMENT' ) then
	   AName = trim(InLine(1:EqPos-1))
	   S = adjustl(InLine(EqPos+1:)) 
	   lastpos=len_trim(S)
	   if (lastpos>1) then
	    if (S(1:1)=='''' .and. S(lastpos:lastpos)=='''') then
	     S = S(2:lastpos-1)
	    end if
	   end if
	end if
	name = AName
	value = S
end subroutine parse_parameter_line
	
function ds_atof(A) result(f)
	character(*) :: A
	real(dp) :: f
	read(A,*) f
end function ds_atof

function ds_atoi(A) result(i)
	character(*) :: A
	integer :: i
	read(A,*) i
end function ds_atoi


function ds_atob(A) result(L)
	character(*) :: A
	logical :: L
	read(A,*) L
end function ds_atob
	
subroutine command_line_override_options(options, first, last)	
	type(ds_cbass_options) :: options
	integer first
	integer, optional :: last
	integer last_param
	integer arg_number
	character(128) :: arg, name, value
	
	if (present(last)) then
		last_param = last
	else
		last_param = iargc()
	endif
	
	do arg_number=first,last_param
		call getarg(arg_number,arg)
		call parse_parameter_line(arg,name,value)
""")
	
	for set_name,option_set in options:
		for name,ptype,default,help in option_set:
			S.write("\t\tif (trim(name)=='%s') options%%%s=%s\n" % (name,name,parse_call_for_type(ptype,'value') ) )
	S.write("""
	enddo

end subroutine command_line_override_options
	""")
		
	S.write("end module ds_cbass_option_utils\n")
	S.seek(0)
	return S.read()





def fits_card(S,i,name,ptype,help):
	key_keyword='DSKEY%.3d'%i
	key_comment=fortran_string(' / Descart parameter %d name' % i,str)
	key_value=fortran_string(name,str)
	
	template_write = "	write(template,'(A,A,A)') '%s  ', %s, %s" % (key_keyword,key_value,key_comment)
	S.write("""%s
	call FTGTHD(trim(template),card,hdutype,status)
	if (status .ne. 0) then 
		write(*,'(A,I0,A)') "ERROR ",status," PARSING:"
		write(*,'(A)') trim(template)
	endif
	call fl_append_string80_list(cards,card)
"""%template_write)

	value_keyword='DSVAL%.3d'%i
	value_comment=fortran_string(' / Descart parameter %d value' % i,str)
	value_value='options%%%s'%name
	if ptype==str: value_value='trim(%s)'%value_value
	template_write = "	write(template,'(A,%s,A)') '%s  ', %s, %s" % (FORTRAN_CODES[ptype],value_keyword,value_value,value_comment)
	S.write("""%s
	call FTGTHD(template,card,hdutype,status)
	if (status .ne. 0) then 
	write(*,'(A,I0,A)') "ERROR ",status," PARSING:"
		write(*,'(A)') trim(template)
	endif
	call fl_append_string80_list(cards,card)
"""%template_write)


#def fits_card(name,ptype,help,i,S):
#	key_keyword=fortran_string("DSKEY%.3d"%i,str)
#	value_keyword=fortran_string("DSVAL%.3d"%i,str)
#	key_value=fortran_string(name,str)
#	value_value="options%%%s"%name
#	code=FITS_CODES[ptype]
#	
#	#Put a keyword describing the name of the descart parameter:
#	S.write('	call FTPKYS(unit,%s,%s,"Descart parameter %d name",status)\n' % (key_keyword,key_value,i))
#
#	#And then the value
#	if ptype in [str,int,bool]:
#		S.write('	call FTPKY%c(unit,%s,%s,"Descart parameter %d value",status)\n' % (code,value_keyword,value_value,i))
#	elif ptype==float:
#		S.write('	call FTPKYD(unit,%s,%s,3,"Descart parameter %d value",status)\n' % (value_keyword,value_value,i))
#
def generate_parameter_file(options,help_text=True):
	S=StringIO.StringIO()
	if help_text:
		S.write("# The default version of this file, %s, is auto-generated by build_options.py.  Edits may be lost when compiling.\n\n"%DEFAULT_PARAMETER_FILENAME)
	else:
		S.write("# The default version of this file, %s, is auto-generated by build_options.py.  Edits may be lost when compiling.\n\n"%SHORT_PARAMETER_FILENAME)
	for set_name,option_set in options:
		S.write("########################\n")		
		S.write("###### %s\n"%set_name)		
		S.write("########################\n\n")
		for name,ptype,default,help in option_set:
			if help_text:
				S.write("#%s\n"%help)
			S.write("%s = %s\n"%(name,ini_string(default,ptype)) )
		S.write('\n')
	S.seek(0)
	return S.read()

file(FORTRAN_FILENAME,"w").write(generate_fortran(options))
file(DEFAULT_PARAMETER_FILENAME,"w").write(generate_parameter_file(options))
file(SHORT_PARAMETER_FILENAME,"w").write(generate_parameter_file(options,help_text=False))
